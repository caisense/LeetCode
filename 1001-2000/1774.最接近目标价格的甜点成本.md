# 1774.最接近目标价格的甜点成本

#### [1774. 最接近目标价格的甜点成本](https://leetcode.cn/problems/closest-dessert-cost/)

baseCosts基料必选，toppingCosts配料不定数量，因此考虑用dfs搜索toppingCosts

```python
class Solution:
    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:
        self.res= sys.maxsize
        self.minDis = sys.maxsize
        self.list= []

        n = len(baseCosts)
        m = len(toppingCosts)
        
        def dfs(i, j, cost):
            if i >=n or j >= m :  #递归出口（这里不能用cost > target条件剪枝
                return
            
            #第j种选k=0~2份
            for k in range(3):
                # 用tmp计算当前cost，不修改cost以保存现场
                tmp = cost + toppingCosts[j]*k
                #找到比res更接近target的数
                if abs(tmp - target) <= abs(self.res - target):
                    #记录下来每个接近target的数
                    #【重点】写入list
                    self.res = tmp
                    self.minDis = abs(tmp - target)
                    self.list.append(tmp)
                dfs(i, j+1, tmp)	#dfs下一种配料

        for i in  range(n):
            dfs(i, 0, baseCosts[i])	#基料必选，因此遍历基料，对每种配料dfs
        #注意求的是【最接近】target的数中，【最小】的。
        #因此还要再次筛选
        #由于【最接近】的距离已经确定，因此只需要在【最接近】的限定范围中找【最小】的
        finalRes=sys.maxsize
        for i in self.list:
            if abs(i - target) <= self.minDis and i < finalRes:
                finalRes = i
        return finalRes      
```


# 99. 恢复二叉搜索树

[https://leetcode-cn.com/problems/recover-binary-search-tree/](https://leetcode-cn.com/problems/recover-binary-search-tree/)

## 解法一：中序

先中序遍历得到结点值列表，然后排序，再中序遍历一次，将排序后的值依次填入即可。空间复杂度O（n）

```python
class Solution:
    def recoverTree(self, root: TreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        vals = []
        def traval(root):    #函数，中序遍历记录所有结点
            if not root:
                return
            traval(root.left)
            vals.append(root.val)
            traval(root.right)
        traval(root)    
        vals.sort()    #值排序
        
        def fill(root):    #函数，第二次遍历，依次填入新值
            if not root:
                return
            fill(root.left)
            root.val = vals[0]
            vals.pop(0)
            fill(root.right)
        fill(root)
```




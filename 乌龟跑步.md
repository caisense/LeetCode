

https://ac.nowcoder.com/acm/contest/70/E?&headNav=www&headNav=acm

用```dp[i][j][k][dir]``` 表示执行到第`i`个字符，用了`j`次操作，能否到达`k`，并朝向`dir`方向

dir只有两个取值，1表示正向，0表示反向

```python
import sys
s = sys.stdin.readline()[:-1]
n = int(input())

dp = [[[[False] * 2 for _ in range(210)] for _ in range(52)] for _ in range(101)]

s = ' ' + s
m = len(s)
dp[0][0][100][1]=True # 起始位置为100
for i in range(1, m):
    for j in range(n+1):
        for k in range(201):
            if s[i] == 'F':
                dp[i][j][k+1][1] |= dp[i-1][j][k][1]    #直接向前
                dp[i][j][k][0] |= dp[i-1][j][k+1][0]    #直接向后
                if j > 0:
                    dp[i][j][k][1] |= dp[i-1][j-1][k][0]    #转向变向后
                    dp[i][j][k][0] |= dp[i-1][j-1][k][1]    #转向变向前
            else:
                dp[i][j][k][1] |= dp[i-1][j][k][0]  #转向
                dp[i][j][k][0] |= dp[i-1][j][k][1]  #转向
                if j > 0:
                    dp[i][j][k+1][1] |= dp[i-1][j-1][k][1]   #转向变向前
                    dp[i][j][k][0] |= dp[i-1][j-1][k+1][0]   #转向变向后
ans = 0
for k in range(201):
    # 若能到达k处，由于起始从100出发，最远到达距离为与100的差值（大于100为正向，小于为反向）
    if dp[m-1][n][k][1]:
        ans = max(ans, abs(100-k))
    if dp[m-1][n][k][0]:
        ans = max(ans, abs(100-k))
print(ans)
```

